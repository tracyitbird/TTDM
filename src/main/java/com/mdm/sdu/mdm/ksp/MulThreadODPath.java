package com.mdm.sdu.mdm.ksp;import com.mdm.sdu.ksp.edu.asu.emit.algorithm.graph.Graph;import com.mdm.sdu.ksp.edu.asu.emit.algorithm.graph.Path;import com.mdm.sdu.ksp.edu.asu.emit.algorithm.graph.VariableGraph;import com.mdm.sdu.ksp.edu.asu.emit.algorithm.graph.shortestpaths.YenTopKShortestPathsAlg;import java.io.*;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.concurrent.ConcurrentLinkedQueue;import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;/** * calculate the shortest path of one trajectory graph using multi-thread. */public class MulThreadODPath implements Runnable {    private static int THREAD_NUMBER = 10;    private static String OD_PATH = "output/graph/Taxi_graph.csv";    private static String OUT_PATH = "output/time1/Taxi_shortest_time.csv";    private static String GRAPH_PATH = "output/graph/Taxi_graph.csv";    private static ConcurrentLinkedQueue<ODData> lbQueue = new ConcurrentLinkedQueue<ODData>();    private static ConcurrentLinkedQueue<String> writeQueue = new ConcurrentLinkedQueue<String>();    private static CountDownLatch countDownLatch = new CountDownLatch(THREAD_NUMBER);    private static Set<ODData> vertex = new HashSet<ODData>();    private static volatile AtomicBoolean working = new AtomicBoolean();    private static AtomicInteger line_Num = new AtomicInteger();    private static BufferedWriter bufferedWriter;    private Graph graph;    private YenTopKShortestPathsAlg yenAlg1;    public MulThreadODPath(Graph graph, YenTopKShortestPathsAlg yenAlgl) {        this.graph = graph;        this.yenAlg1 = yenAlgl;    }    /**     * call this method before start a thread     *     * @throws IOException     */    public static void init() throws IOException {        System.out.println("start init......");        File outfile = new File(OUT_PATH);        if (!outfile.exists()) {            outfile.createNewFile();        }        bufferedWriter = new BufferedWriter(new FileWriter(outfile, true));        line_Num.set(1);        working.set(true);        FileReader input = new FileReader(OD_PATH);        BufferedReader bufReader = new BufferedReader(input);        Set<String> nodeset = new HashSet<String>();        String line = bufReader.readLine();        while (line != null && line != "") {            String[] strList = line.trim().split("\\s+");            if (strList.length == 3) {                String o = strList[0];                String d = strList[1];                nodeset.add(o);                nodeset.add(d);            }            line = bufReader.readLine();        }        for (String node : nodeset) {            for (String node1 : nodeset) {                if (!node1.equals(node)) {                    ODData od = new ODData(Long.parseLong(node), Long.parseLong(node1));                    vertex.add(od);//直接使用Set去重                }            }        }        bufReader.close();        lbQueue.addAll(vertex);        System.out.println("the number of all od is: " + lbQueue.size());    }    public void run() {        ODData od;        List<Path> short_paths_list;        StringBuilder stringBuilder = new StringBuilder();        while (working.get()) {                od = lbQueue.poll();                if (line_Num.getAndIncrement() % 1000 == 0) {                    System.out.println("present processed line: " + line_Num );                }                if (od != null) {                    short_paths_list = yenAlg1.getShortestPaths(graph.getVertex(od.getO()), graph.getVertex(od.getD()), 1);                    for (Path path : short_paths_list) {                        stringBuilder.append(path.toString() + "\n");                        writeQueue.offer(stringBuilder.toString());                        stringBuilder.delete(0, stringBuilder.length());                    }                }else{                    working.compareAndSet(true,false) ;                }            }        countDownLatch.countDown();    }    public static void write(String content) {        try {            bufferedWriter.write(content);        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        try {            MulThreadODPath.init();        } catch (IOException e) {            System.exit(-1);        }        for (int i = 0; i < THREAD_NUMBER; i++) {            Graph graph = new VariableGraph(GRAPH_PATH);            YenTopKShortestPathsAlg yenAlgl = new YenTopKShortestPathsAlg(graph);            MulThreadODPath odPath = new MulThreadODPath(graph, yenAlgl);            Thread thread = new Thread(odPath, "thread" + i);            thread.start();        }        try {            countDownLatch.await();            System.out.println("thread left:"+countDownLatch.getCount());        } catch (InterruptedException e) {            e.printStackTrace();        }        while (!writeQueue.isEmpty()) {            String content = writeQueue.poll();            write(content);        }        try {            bufferedWriter.flush();            bufferedWriter.close();        } catch (IOException e) {            e.printStackTrace();        }    }}